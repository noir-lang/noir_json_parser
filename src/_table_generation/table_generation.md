# Table Generation Documentation

## Overview
The JSON parser uses lookup tables to avoid branching logic and reduce gate count. These tables are generated from `src/_table_generation/make_tables.nr`.

## Generation Process
Tables are generated by simulating all possible input combinations from basic hardcoded tables and recording the expected outputs.

## TOKEN_FLAGS_TABLE
Maps (token, context) pairs to parsing flags:
- `create_json_entry`: Whether to create a JSON entry for this token, set to true if token is literal/number/string(not key)/end of array/object
- `is_end_of_object_or_array`: Whether token ends an object/array
- `is_start_of_object_or_array`: Whether token starts an object/array
- `new_context`: What context to switch to, object is 0, array is 1
- `is_key_token`: Whether token is a key
- `is_value_token`: Whether token is a value, set to True for string_token, numeric_token, and literal_token
- `preserve_num_entries`: boolean flag that controls whether the current token should preserve the existing count of entries at the current depth or reset/increment it. 1 for tokens like NO_TOKEN, KEY_TOKEN, STRING_TOKEN, NUMERIC_TOKEN, LITERAL_TOKEN
0 for tokens like OBJECT_START_TOKEN, ARRAY_START_TOKEN, OBJECT_END_TOKEN, ARRAY_END_TOKEN

## JSON_CAPTURE_TABLE
Maps (escape_flag, scan_mode, ascii) to scanning actions:
- `scan_token`: Next capture mode based on current capture mode, can be grammar_capture([,{,comma,},],:)/string_capture/literal_capture/numeric_capture/error_capture. For example, if currently we are in string capture, and character is ", then scan_token will be set to grammar_capture because we are at end of string, back to grammar scan. If we are in numeric scan, and current character is not 0-9, then we are back to grammar scan as we expect the number has ended.
- `push_transcript`: Whether to add token to transcript: in grammar mode: true for all structual elements[,{,comma,},],:. In string_capture, true for ", which signals string end. In numeric/literal_capture, true for space, \t, \n, \r, ", and comma. Note the first scan will not pick up numerics or literals because we don't know when they end, so we need to rely on capture_missing_tokens function.
- `increase_length`: Whether to extend current token, always false for grammar_capture, true for 0-9 in numeric capture, all characters except for " in string_capture, all letters in true, false, null in literal_capture
- `is_potential_escape_sequence`: true if current token is / in string_capture mode

## Other tables
While TOKEN_FLAGS_TABLE and JSON_CAPTURE_TABLE are the more important tables, they are built from foundational hardcoded tables in make_tables_subtables.nr:

GRAMMAR_CAPTURE_TABLE: State transition table for grammar scan mode. Each entry specifies the next scan mode (GRAMMAR_CAPTURE, STRING_CAPTURE, NUMERIC_CAPTURE, LITERAL_CAPTURE, or ERROR_CAPTURE) based on the encountered ASCII character. For example, "f" is mapped to LITEAL_CAPTURE because it indicates we began to scan the literal false.
STRING_CAPTURE_TABLE
NUMERIC_CAPTURE_TABLE
LITERAL_CAPTURE_TABLE

GRAMMAR_CAPTURE_TOKEN: Maps characters in grammar mode to token types. Converts ASCII characters into the appropriate JSON token types for structural elements, values, and literals.
 Structural characters ({, }, [, ], ,, :) → their respective structural tokens
- Quote (") → STRING_TOKEN (start of string)
- Digits (0-9) → NUMERIC_TOKEN (start of number)
- Literal starters (f, t, n) → LITERAL_TOKEN (start of true/false/null)
- Invalid characters → NO_TOKEN or error handling
STRING_CAPTURE_TOKEN
NUMERIC_CAPTURE_TOKEN
LITERAL_CAPTURE_TOKEN

STRING_CAPTURE_PUSH_TRANSCRIPT: Determines when to add tokens to the transcript while scanning inside a string. Only true for the closing quote ("). This signals the end of the string and triggers token creation. All other characters within the string (letters, numbers, punctuation, spaces) are false because they extend the current string token rather than creating new tokens.

GRAMMAR_CAPTURE_PUSH_TRANSCRIPT: Determines when to add tokens to the transcript while scanning in grammar mode. True for the following characters:
- Comma (,) → true (value separator)
- Colon (:) → true (key-value separator)
- All other characters → false (including digits, quotes, and literal starters)

NUMERIC_CAPTURE_PUSH_TRANSCRIPT: Determines when to add the current numeric token to the transcript while scanning a number. True for the following characters:
- Whitespace (space, tab, newline, carriage return) → true (end number)
- Quote (") → true (end number, followed by string)
- Comma (,) → true (end number, followed by next value)
- All other characters → false (extend current number or error)

LITERAL_CAPTURE_PUSH_TRANSCRIPT: Determines when to add the current literal token (true/false/null) to the transcript while scanning a literal. True for any grammar character: , [ ] { } " space tab newline (This is only used in the first scan, in the second step capture_missing_tokens, we will be able to separate the literal and value separator)

GRAMMAR_CAPTURE_INCREASE_LENGTH: Determines when to extend the current token length while scanning in grammar mode. True for Digits (0-9) -> starting numeric scan, Letters for literals (f, t, n, r, u, e, a, l, s) -> starting literal scan. For structural tokens, we don't count its length (is just  1). For string tokens, we are expecting to see a " first before seeing letters.

STRING_CAPTURE_INCREASE_LENGTH: Determines when to extend the current string token while scanning inside a string. True for all printable characters except for Quote (ends the string)
NUMERIC_CAPTURE_INCREASE_LENGTH: True for 0-9
LITERAL_CAPTURE_INCREASE_LENGTH: True for t,r,u,e,f,a,l,s,n

GRAMMAR_CAPTURE_ERROR_FLAG
STRING_CAPTURE_ERROR_FLAG
NUMERIC_CAPTURE_ERROR_FLAG
LITERAL_CAPTURE_ERROR_FLAG

PROCESS_RAW_TRANSCRIPT_TABLE: This table is used to post-process the raw transcript and add missing grammar tokens that were not captured during the initial scanning in build_transcript. Input: encoded_ascii of the last token in each entry (scan_mode + ascii character). Output: containing: token: The token type for this entry, new_grammar: Whether to add a missing grammar token, and scan_token: The type of grammar token to add (if needed), such as END_OBJECT_TOKEN }, or VALUE_SEPARATOR_TOKEN comma.